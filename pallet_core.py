{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "5336cd96-9a37-46da-8a0b-82ca397cbeaa",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "每层容量（固定/计算）： {'Kozed60': 12, 'Kozed24': 12, 'CandyMaster': 12, 'Crisup20': 9, 'Crisup24': 7}\n",
      "每板容量（@60in）： {'Kozed60': 72, 'Kozed24': 144, 'CandyMaster': 108, 'Crisup20': 99, 'Crisup24': 42}\n",
      "\n",
      "订单 {'Kozed60': 0, 'Kozed24': 0, 'Crisup24': 0, 'Crisup20': 250, 'CandyMaster': 0} -> 需要 3 个 pallet\n",
      "\n",
      "Pallet 1: load={'Crisup20': 99}\n",
      "  Layer  1: Crisup20 x 9\n",
      "  Layer  2: Crisup20 x 9\n",
      "  Layer  3: Crisup20 x 9\n",
      "  Layer  4: Crisup20 x 9\n",
      "  Layer  5: Crisup20 x 9\n",
      "  Layer  6: Crisup20 x 9\n",
      "  Layer  7: Crisup20 x 9\n",
      "  Layer  8: Crisup20 x 9\n",
      "  Layer  9: Crisup20 x 9\n",
      "  Layer 10: Crisup20 x 9\n",
      "  Layer 11: Crisup20 x 9\n",
      "\n",
      "Pallet 2: load={'Crisup20': 99}\n",
      "  Layer  1: Crisup20 x 9\n",
      "  Layer  2: Crisup20 x 9\n",
      "  Layer  3: Crisup20 x 9\n",
      "  Layer  4: Crisup20 x 9\n",
      "  Layer  5: Crisup20 x 9\n",
      "  Layer  6: Crisup20 x 9\n",
      "  Layer  7: Crisup20 x 9\n",
      "  Layer  8: Crisup20 x 9\n",
      "  Layer  9: Crisup20 x 9\n",
      "  Layer 10: Crisup20 x 9\n",
      "  Layer 11: Crisup20 x 9\n",
      "\n",
      "Pallet 3: load={'Crisup20': 52}\n",
      "  Layer  1: Crisup20 x 9\n",
      "  Layer  2: Crisup20 x 9\n",
      "  Layer  3: Crisup20 x 9\n",
      "  Layer  4: Crisup20 x 9\n",
      "  Layer  5: Crisup20 x 9\n",
      "  Layer  6: Crisup20 x 7\n"
     ]
    }
   ],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "import math\n",
    "from dataclasses import dataclass\n",
    "from typing import Dict, List, Tuple\n",
    "\n",
    "# ---------------- Pallet spec ----------------\n",
    "PALLET_L, PALLET_W, PALLET_H = 48.0, 46.0, 60.0  # inches\n",
    "\n",
    "@dataclass\n",
    "class Case:\n",
    "    L: float; W: float; H: float  # inches\n",
    "\n",
    "# ---------------- Product cases dimension ----------------\n",
    "Kozed60      = Case(16.00, 10.00, 10.00)   \n",
    "Kozed24      = Case(15.50, 10.00,  4.80)   \n",
    "Crisup24     = Case(20.39, 12.60,  8.85)   \n",
    "Crisup20     = Case(15.94, 13.19,  5.12)   \n",
    "CandyMaster  = Case(15.50,  9.00,  6.20)   \n",
    "\n",
    "# 函数里查 Case\n",
    "CASES: Dict[str, Case] = {\n",
    "    \"Kozed60\": Kozed60,\n",
    "    \"Kozed24\": Kozed24,\n",
    "    \"Crisup24\": Crisup24,\n",
    "    \"Crisup20\": Crisup20,\n",
    "    \"CandyMaster\": CandyMaster,\n",
    "}\n",
    "\n",
    "# 要求可以混向拼装\n",
    "def mixed_orient_layer_capacity(case: Case, L=PALLET_L, W=PALLET_W) -> int:\n",
    "    \"\"\"\n",
    "    同层可混向：未旋转(LxW) + 旋转90°(WxL)；高度不参与旋转。\n",
    "    思路：把地面切成‘未旋转条带 + 旋转条带’，两种方向各穷举一次，取最大。\n",
    "    \"\"\"\n",
    "    L1, W1 = case.L, case.W      # 未旋转占地\n",
    "    L2, W2 = case.W, case.L      # 旋转90°占地\n",
    "    best = 0\n",
    "\n",
    "    # A) 按宽度切分\n",
    "    max_rows_unrot = math.floor(W / W1)\n",
    "    for r in range(max_rows_unrot + 1):\n",
    "        used_w = r * W1\n",
    "        if used_w > W: break\n",
    "        cols_unrot = math.floor(L / L1)\n",
    "        cnt_unrot  = r * cols_unrot\n",
    "        rem_w = W - used_w\n",
    "        rows_rot = math.floor(rem_w / W2)\n",
    "        cols_rot = math.floor(L / L2)\n",
    "        cnt_rot  = rows_rot * cols_rot\n",
    "        best = max(best, cnt_unrot + cnt_rot)\n",
    "\n",
    "    # B) 按长度切分\n",
    "    max_cols_unrot = math.floor(L / L1)\n",
    "    for c in range(max_cols_unrot + 1):\n",
    "        used_l = c * L1\n",
    "        if used_l > L: break\n",
    "        rows_unrot = math.floor(W / W1)\n",
    "        cnt_unrot  = c * rows_unrot\n",
    "        rem_l = L - used_l\n",
    "        cols_rot = math.floor(rem_l / L2)\n",
    "        rows_rot = math.floor(W / W2)\n",
    "        cnt_rot  = cols_rot * rows_rot\n",
    "        best = max(best, cnt_unrot + cnt_rot)\n",
    "\n",
    "    # 纯单向兜底\n",
    "    pure1 = math.floor(L / L1) * math.floor(W / W1)\n",
    "    pure2 = math.floor(L / L2) * math.floor(W / W2)\n",
    "    return max(best, pure1, pure2)\n",
    "\n",
    "# ---------------- 每层容量（固定 / 计算） ----------------\n",
    "PER_LAYER: Dict[str, int] = {\n",
    "    \"Kozed60\":     12,  # 固定\n",
    "    \"Kozed24\":     12,  # 固定\n",
    "    \"CandyMaster\": 12,  # 固定\n",
    "    \"Crisup20\":     9,  # 固定\n",
    "    # Crisup24 默认“混向最优”；如需固定为 6/层或 7/层，改成 6 或 7 即可：\n",
    "    \"Crisup24\": mixed_orient_layer_capacity(Crisup24),\n",
    "}\n",
    "\n",
    "# ---------------- 层数与每板容量（A 无上限，按高度计算） ----------------\n",
    "def layers_at_height(case: Case) -> int:\n",
    "    return math.floor(PALLET_H / case.H)\n",
    "\n",
    "CPP = {\n",
    "    \"Kozed60\":     lambda: PER_LAYER[\"Kozed60\"]     * layers_at_height(Kozed60),\n",
    "    \"Kozed24\":     lambda: PER_LAYER[\"Kozed24\"]     * layers_at_height(Kozed24),\n",
    "    \"Crisup24\":    lambda: PER_LAYER[\"Crisup24\"]    * layers_at_height(Crisup24),\n",
    "    \"Crisup20\":    lambda: PER_LAYER[\"Crisup20\"]    * layers_at_height(Crisup20),\n",
    "    \"CandyMaster\": lambda: PER_LAYER[\"CandyMaster\"] * layers_at_height(CandyMaster),\n",
    "}\n",
    "\n",
    "# ---------------- 整板优先（也作为默认层序：自下而上） ----------------\n",
    "FULL_PALLET_ORDER = [\"Kozed60\", \"Kozed24\", \"CandyMaster\", \"Crisup24\", \"Crisup20\"]\n",
    "\n",
    "# ---------------- 先做整板（含逐层明细） ----------------\n",
    "def carve_full_pallets(orders: Dict[str, int]) -> Tuple[List[Dict], Dict[str,int]]:\n",
    "    pallets: List[Dict] = []\n",
    "    remain = orders.copy()\n",
    "    for sku in FULL_PALLET_ORDER:\n",
    "        q = remain.get(sku, 0)\n",
    "        if q <= 0:\n",
    "            continue\n",
    "        per = CPP[sku]()\n",
    "        k = q // per\n",
    "        if k <= 0:\n",
    "            continue\n",
    "        case_layers = layers_at_height(CASES[sku])\n",
    "        per_layer  = PER_LAYER[sku]\n",
    "        for _ in range(k):\n",
    "            layer_plan = []\n",
    "            for li in range(1, case_layers+1):\n",
    "                layer_plan.append({\"layer\": li, \"sku\": sku, \"qty\": per_layer})\n",
    "            pallets.append({\"load\": {sku: per}, \"layer_plan\": layer_plan})\n",
    "        remain[sku] = q - k * per\n",
    "    return pallets, remain\n",
    "\n",
    "# ---------------- 枚举“整层”混装 pattern ----------------\n",
    "def enumerate_patterns() -> List[Dict]:\n",
    "    max_layers = {sku: layers_at_height(CASES[sku]) for sku in CASES.keys()}\n",
    "    pats: List[Dict] = []\n",
    "    for a in range(max_layers[\"Kozed60\"]+1):\n",
    "        for b in range(max_layers[\"Kozed24\"]+1):\n",
    "            for e in range(max_layers[\"CandyMaster\"]+1):\n",
    "                for c in range(max_layers[\"Crisup24\"]+1):\n",
    "                    for d in range(max_layers[\"Crisup20\"]+1):\n",
    "                        if a==b==e==c==d==0:\n",
    "                            continue\n",
    "                        height = (\n",
    "                            a*CASES[\"Kozed60\"].H +\n",
    "                            b*CASES[\"Kozed24\"].H +\n",
    "                            e*CASES[\"CandyMaster\"].H +\n",
    "                            c*CASES[\"Crisup24\"].H +\n",
    "                            d*CASES[\"Crisup20\"].H\n",
    "                        )\n",
    "                        if height <= PALLET_H + 1e-6:\n",
    "                            cap = {\n",
    "                                \"Kozed60\":     a*PER_LAYER[\"Kozed60\"],\n",
    "                                \"Kozed24\":     b*PER_LAYER[\"Kozed24\"],\n",
    "                                \"CandyMaster\": e*PER_LAYER[\"CandyMaster\"],\n",
    "                                \"Crisup24\":    c*PER_LAYER[\"Crisup24\"],\n",
    "                                \"Crisup20\":    d*PER_LAYER[\"Crisup20\"],\n",
    "                            }\n",
    "                            layers = {\n",
    "                                \"Kozed60\": a, \"Kozed24\": b, \"CandyMaster\": e,\n",
    "                                \"Crisup24\": c, \"Crisup20\": d\n",
    "                            }\n",
    "                            pats.append({\"layers\": layers, \"height\": height, \"cap\": cap})\n",
    "    # 大容量优先，其次高度利用\n",
    "    pats.sort(key=lambda p: (sum(p[\"cap\"].values()), p[\"height\"]), reverse=True)\n",
    "    return pats\n",
    "\n",
    "PATTERNS = enumerate_patterns()\n",
    "\n",
    "# ---------------- 把某块板的装载量分解成逐层明细 ----------------\n",
    "def build_layer_plan_from_pattern(load: Dict[str,int], pat_layers: Dict[str,int]) -> List[Dict]:\n",
    "    plan: List[Dict] = []\n",
    "    layer_index = 1\n",
    "    for sku in FULL_PALLET_ORDER:\n",
    "        qty = load.get(sku, 0)\n",
    "        if qty <= 0:\n",
    "            continue\n",
    "        per_layer = PER_LAYER[sku]\n",
    "        max_layers_for_sku = pat_layers.get(sku, 0)\n",
    "        full_layers = min(max_layers_for_sku, qty // per_layer)\n",
    "        rem = qty - full_layers * per_layer\n",
    "        # 整层\n",
    "        for _ in range(full_layers):\n",
    "            plan.append({\"layer\": layer_index, \"sku\": sku, \"qty\": per_layer})\n",
    "            layer_index += 1\n",
    "        # 部分层（如果有余量且还有层配额）\n",
    "        if rem > 0 and full_layers < max_layers_for_sku:\n",
    "            plan.append({\"layer\": layer_index, \"sku\": sku, \"qty\": rem})\n",
    "            layer_index += 1\n",
    "    return plan\n",
    "\n",
    "# ---------------- 混装（贪心 + 小合并）：权重体现优先级 ----------------\n",
    "def pack_mixed(remain: Dict[str,int]) -> Tuple[int, List[Dict]]:\n",
    "    rem = {k:v for k,v in remain.items() if v>0}\n",
    "    pallets: List[Dict] = []\n",
    "    WEIGHTS = {\"Kozed60\":1.3, \"Kozed24\":1.2, \"CandyMaster\":1.2, \"Crisup24\":1.0, \"Crisup20\":1.0}\n",
    "\n",
    "    def score(p):\n",
    "        cap = p[\"cap\"]\n",
    "        take_sum = sum(min(rem.get(k,0), v) for k,v in cap.items())\n",
    "        cap_sum  = sum(cap.values()) or 1\n",
    "        fill     = take_sum / cap_sum      # 填充率（惩罚半层）\n",
    "        eff      = sum(min(rem.get(k,0), v) * WEIGHTS.get(k,1.0) for k,v in cap.items())\n",
    "        return eff * (0.6 + 0.4*fill)\n",
    "\n",
    "    while any(rem.get(s,0)>0 for s in CASES.keys()):\n",
    "        best = max(PATTERNS, key=score)\n",
    "        cap  = best[\"cap\"]\n",
    "        lays = best[\"layers\"]\n",
    "        load: Dict[str,int] = {}\n",
    "        for k, cap_k in cap.items():\n",
    "            if cap_k>0 and rem.get(k,0)>0:\n",
    "                take = min(cap_k, rem[k])  # 允许层内不满；评分已惩罚\n",
    "                if take>0:\n",
    "                    load[k] = take\n",
    "                    rem[k] -= take\n",
    "        if not load:\n",
    "            # 兜底：剩余最多的 SKU 做单品一板\n",
    "            k = max(rem.keys(), key=lambda s: rem[s])\n",
    "            per = CPP[k](); take = min(per, rem[k])\n",
    "            load = {k: take}; lays = {k: layers_at_height(CASES[k])}\n",
    "            rem[k] -= take\n",
    "        layer_plan = build_layer_plan_from_pattern(load, lays)\n",
    "        pallets.append({\"load\": load, \"layer_plan\": layer_plan})\n",
    "\n",
    "    # 小合并：若有 pattern 可以容纳两块板的合计，则合并\n",
    "    merged = True\n",
    "    while merged and len(pallets) >= 2:\n",
    "        merged = False\n",
    "        for i in range(len(pallets)-1):\n",
    "            for j in range(i+1, len(pallets)):\n",
    "                comb_load = {k: pallets[i][\"load\"].get(k,0) + pallets[j][\"load\"].get(k,0) for k in CASES.keys()}\n",
    "                fit = None\n",
    "                for p in PATTERNS:\n",
    "                    if all(comb_load.get(k,0) <= p[\"cap\"].get(k,0) for k in CASES.keys()):\n",
    "                        fit = p; break\n",
    "                if fit:\n",
    "                    comb_plan = build_layer_plan_from_pattern(comb_load, fit[\"layers\"])\n",
    "                    pallets[i] = {\"load\": comb_load, \"layer_plan\": comb_plan}\n",
    "                    pallets.pop(j)\n",
    "                    merged = True\n",
    "                    break\n",
    "            if merged: break\n",
    "    return len(pallets), pallets\n",
    "\n",
    "# ---------------- 入口 ----------------\n",
    "def plan_min_pallets(orders: Dict[str,int]) -> Tuple[int, List[Dict]]:\n",
    "    # 单品短路（也生成层计划）\n",
    "    nz = [k for k,v in orders.items() if v>0]\n",
    "    if len(nz) <= 1:\n",
    "        if not nz: return 0,[]\n",
    "        sku = nz[0]; per = CPP[sku]()\n",
    "        case_layers = layers_at_height(CASES[sku])\n",
    "        per_layer   = PER_LAYER[sku]\n",
    "        pallets: List[Dict] = []\n",
    "        qty = orders[sku]\n",
    "        while qty > 0:\n",
    "            take = min(per, qty)\n",
    "            full_layers = min(case_layers, take // per_layer)\n",
    "            rem = take - full_layers*per_layer\n",
    "            layer_plan = []\n",
    "            li = 1\n",
    "            for _ in range(full_layers):\n",
    "                layer_plan.append({\"layer\": li, \"sku\": sku, \"qty\": per_layer}); li += 1\n",
    "            if rem > 0 and full_layers < case_layers:\n",
    "                layer_plan.append({\"layer\": li, \"sku\": sku, \"qty\": rem})\n",
    "            pallets.append({\"load\": {sku: take}, \"layer_plan\": layer_plan})\n",
    "            qty -= take\n",
    "        return len(pallets), pallets\n",
    "\n",
    "    # 先做整板（Kozed60 -> Kozed24 -> CandyMaster -> Crisup24 -> Crisup20）\n",
    "    full, remain = carve_full_pallets(orders)\n",
    "    # 再混装\n",
    "    mix_n, mix_plan = pack_mixed(remain)\n",
    "    return len(full)+mix_n, full+mix_plan\n",
    "\n",
    "# ---------------- test ----------------\n",
    "if __name__ == \"__main__\":\n",
    "    print(\"每层容量（固定/计算）：\", PER_LAYER)\n",
    "    print(\"每板容量（@60in）：\", {k: CPP[k]() for k in PER_LAYER.keys()})\n",
    "\n",
    "    # test\n",
    "    orders = {\"Kozed60\": 0, \"Kozed24\": 0, \"Crisup24\": 0, \"Crisup20\": 250, \"CandyMaster\": 0}\n",
    "    total, pallets = plan_min_pallets(orders)\n",
    "    print(f\"\\n订单 {orders} -> 需要 {total} 个 pallet\")\n",
    "    for i, pal in enumerate(pallets, 1):\n",
    "        print(f\"\\nPallet {i}: load={pal['load']}\")\n",
    "        for row in pal[\"layer_plan\"]:\n",
    "            print(f\"  Layer {row['layer']:>2}: {row['sku']} x {row['qty']}\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "e560c4bd-5f87-45e2-8b9c-abf33148644c",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
